@typeparam TItem
@implements IDisposable
@inject ITablePreferencesService TablePreferencesService
@inject IDialogService DialogService
@inject ITranslationService TranslationService
@inject ILogger<EFTable<TItem>> Logger
@inject IJSRuntime JSRuntime
@inject HttpClient Http
@inject ISnackbar Snackbar

@if (AllowDragDropGrouping && ServerData == null)
{
    <MudPaper Elevation="0" Class="mb-2 pa-3" Style="border: 2px dashed var(--mud-palette-lines-default); min-height: 50px; background-color: var(--mud-palette-surface);">
        <div @ondragover="@HandleGroupPanelDragOver"
             @ondragover:preventDefault="true"
             @ondrop="@HandleGroupPanelDrop"
             @ondrop:preventDefault="true"
             style="min-height: 40px;">
            @if (_groupByProperties.Count == 0)
            {
                <div class="d-flex align-center justify-center" style="height: 40px;">
                    <MudIcon Icon="@Icons.Material.Outlined.DragIndicator" Size="Size.Small" Class="mr-2 mud-text-secondary" />
                    <MudText Typo="Typo.body2" Color="Color.Secondary">
                        @TranslationService.GetTranslation("table.dragColumnToGroup", "Trascina qui un'intestazione di colonna per raggruppare")
                    </MudText>
                </div>
            }
            else
            {
                <div class="d-flex align-center gap-2 flex-wrap">
                    @foreach (var (groupProperty, index) in _groupByProperties.Select((prop, idx) => (prop, idx)))
                    {
                        <MudChip T="string"
                                 Color="@(index == 0 ? Color.Primary : Color.Secondary)"
                                 OnClose="@(() => RemoveGrouping(groupProperty))"
                                 Size="Size.Medium">
                            <MudIcon Icon="@Icons.Material.Outlined.Category" Size="Size.Small" Class="mr-1" />
                            @GetColumnDisplayName(groupProperty)
                            @if (_groupByProperties.Count > 1)
                            {
                                <MudChip T="string" Size="Size.Small" Class="ml-1" Style="height: 20px; font-size: 0.7rem;">
                                    @(index + 1)
                                </MudChip>
                            }
                        </MudChip>
                    }
                </div>
            }
        </div>
    </MudPaper>
}

@if (ShowFilters && _filtersExpanded && FiltersPanel != null)
{
    <MudPaper Elevation="1" Class="mb-2 pa-3">
        @FiltersPanel
    </MudPaper>
}

@* 
    NOTE: Virtualization Support
    The Virtualize parameter is defined for future compatibility.
    MudBlazor 8.14.0 does not natively support the Virtualize parameter on MudTable.
    When MudBlazor is upgraded to a version that supports virtualization (v9+),
    or if custom virtualization is implemented, this parameter can be passed through.
    For now, it serves as documentation and conditional rendering optimization hint.
*@
<MudTable @ref="_tableRef"
          T="TItem"
          Items="@GetDisplayItems()"
          ServerData="@ServerData"
          MultiSelection="@MultiSelection"
          SelectedItems="@SelectedItems"
          SelectedItemsChanged="@SelectedItemsChanged"
          OnRowClick="@OnRowClick"
          Hover="@Hover"
          Striped="@Striped"
          Dense="@Dense"
          FixedHeader="@FixedHeader"
          Height="@Height"
          Loading="@IsLoading"
          LoadingProgressColor="@LoadingProgressColor"
          SortLabel="@(TranslationService.GetTranslation("tooltip.sortColumn", "Ordina colonna"))"
          Breakpoint="@Breakpoint"
          RowsPerPage="@RowsPerPage"
          AllowUnsorted="true">
    <ToolBarContent>
        @if (ToolBarContent != null)
        {
            @ToolBarContent
        }
        else
        {
            @* Built-in toolbar when no custom toolbar is provided *@
            @if (!string.IsNullOrEmpty(Title))
            {
                <MudStack Row="false" Spacing="0">
                    <MudText Typo="Typo.h5">@Title</MudText>
                    @if (!string.IsNullOrEmpty(Subtitle))
                    {
                        <MudText Typo="Typo.body2" Class="mud-text-secondary">@Subtitle</MudText>
                    }
                </MudStack>
            }
            <MudSpacer />
            @if (ShowSearch)
            {
                <MudTextField @bind-Value="_searchTerm"
                              @bind-Value:after="@(async () => await OnSearchTermChanged(_searchTerm))"
                              Label="@(SearchPlaceholder ?? TranslationService.GetTranslation("table.search", "Cerca"))"
                              Variant="Variant.Outlined"
                              Adornment="Adornment.End"
                              AdornmentIcon="@Icons.Material.Outlined.Search"
                              Clearable="true"
                              Dense="true"
                              Class="mr-2"
                              Style="max-width: 300px;" />
            }
            @if (ShowFilters)
            {
                <MudIconButton Icon="@Icons.Material.Outlined.FilterList"
                               Color="@(_filtersExpanded ? Color.Primary : Color.Default)"
                               OnClick="@ToggleFilters"
                               Size="Size.Small" />
            }
            @if (ShowExport && ExportFormats.Any())
            {
                <MudMenu Icon="@Icons.Material.Outlined.Download"
                         Color="Color.Default"
                         Dense="true"
                         Size="Size.Small">
                    @foreach (var format in ExportFormats)
                    {
                        @if (format == "Excel" && EnableExcelExport)
                        {
                            <MudMenuItem OnClick="@HandleExportToExcel" Disabled="@_isExporting">
                                @if (_isExporting)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                }
                                else
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.TableView" Size="Size.Small" Class="mr-2" />
                                }
                                @format
                            </MudMenuItem>
                        }
                        else
                        {
                            <MudMenuItem OnClick="@(async () => await HandleExport(format))">
                                @format
                            </MudMenuItem>
                        }
                    }
                </MudMenu>
            }
            @if (UseDefaultActions && OnAdd.HasDelegate)
            {
                <MudIconButton Icon="@Icons.Material.Outlined.Add"
                               Color="Color.Primary"
                               OnClick="@HandleAdd"
                               Size="Size.Small" />
            }
            @if (Actions != null && Actions.Any())
            {
                @foreach (var action in Actions.Where(a => a.IsEnabled))
                {
                    <MudTooltip Text="@(action.Tooltip ?? action.Label)">
                        <MudIconButton Icon="@(action.Icon ?? Icons.Material.Outlined.MoreVert)"
                                       Color="@(Enum.Parse<Color>(action.Color ?? "Default"))"
                                       OnClick="@(async () => await HandleCustomAction(action.Id))"
                                       Size="Size.Small"
                                       Disabled="@(action.RequiresSelection && !SelectedItems.Any())" />
                    </MudTooltip>
                }
            }
        }
        @if (ShowColumnConfiguration)
        {
            <MudMenu Icon="@Icons.Material.Outlined.Settings"
                     Color="Color.Default"
                     AnchorOrigin="Origin.BottomRight"
                     TransformOrigin="Origin.TopRight"
                     Dense="true"
                     Size="Size.Small">
                <MudMenuItem Icon="@Icons.Material.Outlined.ViewColumn"
                           OnClick="@OpenColumnConfigurationDialog">
                    @TranslationService.GetTranslation("table.configuration", "Configurazione")
                </MudMenuItem>
                <MudMenuItem Icon="@Icons.Material.Outlined.RestartAlt"
                           OnClick="@ResetPreferences">
                    @TranslationService.GetTranslation("table.resetPreferences", "Ripristina impostazioni")
                </MudMenuItem>
            </MudMenu>
        }
    </ToolBarContent>
    <HeaderContent>
        @if (HeaderContent != null)
        {
            @HeaderContent(_columnConfigurations)
        }
    </HeaderContent>
    <RowTemplate>
        @if (RowTemplate != null)
        {
            if (_groupByProperties.Count > 0)
            {
                // Client-side multi-level grouping enabled
                @for (int level = 0; level < _groupByProperties.Count; level++)
                {
                    var groupProperty = _groupByProperties[level];
                    var currentGroupValue = GetPropertyValue(context, groupProperty);
                    
                    if (!_lastGroupValues.ContainsKey(level) || !Equals(currentGroupValue, _lastGroupValues[level]))
                    {
                        _lastGroupValues[level] = currentGroupValue;
                        
                        // Clear deeper level values when a parent level changes
                        for (int deeperLevel = level + 1; deeperLevel < _groupByProperties.Count; deeperLevel++)
                        {
                            _lastGroupValues.Remove(deeperLevel);
                        }
                        
                        var groupItems = GetDisplayItems()
                            .Where(item => GroupItemsMatch(item, level))
                            .ToList();
                        
                        <tr style="background-color: var(--mud-palette-table-lines); font-weight: 600;">
                            <td colspan="100" style="@GetGroupRowStyle(level)">
                                <div class="d-flex align-center">
                                    <MudIcon Icon="@Icons.Material.Outlined.Category" Size="Size.Small" Class="mr-2" />
                                    <MudText Typo="Typo.body2">
                                        @GetColumnDisplayName(groupProperty): @(currentGroupValue?.ToString() ?? TranslationService.GetTranslation("table.noGroup", "(Nessun gruppo)"))
                                        <MudChip T="string" Size="Size.Small" Class="ml-2">@groupItems.Count</MudChip>
                                    </MudText>
                                </div>
                            </td>
                        </tr>
                    }
                }
            }
            @RowTemplate(context)
        }
    </RowTemplate>
    <NoRecordsContent>
        @if (NoRecordsContent != null)
        {
            @NoRecordsContent
        }
        else
        {
            <div class="text-center pa-4">
                <MudIcon Icon="@Icons.Material.Outlined.Info" Size="Size.Medium" Class="mb-2 mud-text-secondary" />
                <MudText Typo="Typo.h6">@TranslationService.GetTranslation("table.noRecords", "Nessun record trovato")</MudText>
            </div>
        }
    </NoRecordsContent>
    <PagerContent>
        @if (ShowInternalPager)
        {
            @if (PagerContent != null)
            {
                @PagerContent
            }
            else
            {
                <MudTablePager RowsPerPageString="@TranslationService.GetTranslation("table.rowsPerPage", "Righe per pagina:")" 
                               PageSizeOptions="@PageSizeOptions" />
            }
        }
    </PagerContent>
    <FooterContent>
        @if (ShowFooter)
        {
            <MudTh colspan="100" Style="text-align: center; background-color: var(--mud-palette-background-grey); font-weight: 500;">
                <MudText Typo="Typo.body2">
                    @TranslationService.GetTranslation("table.totalRecords", "Totale"): @GetTotalCount()
                </MudText>
            </MudTh>
        }
    </FooterContent>
</MudTable>

@code {
    // Table reference
    private MudTable<TItem>? _tableRef;

    // Header parameters
    [Parameter] public string? Title { get; set; }
    [Parameter] public string? Subtitle { get; set; }
    
    // Data parameters
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    [Parameter] public Func<TableState, CancellationToken, Task<TableData<TItem>>>? ServerData { get; set; }

    // Selection parameters
    [Parameter] public bool MultiSelection { get; set; }
    [Parameter] public HashSet<TItem> SelectedItems { get; set; } = new();
    [Parameter] public EventCallback<HashSet<TItem>> SelectedItemsChanged { get; set; }
    
    // Search parameters
    [Parameter] public bool ShowSearch { get; set; } = false;
    [Parameter] public string? SearchPlaceholder { get; set; }
    [Parameter] public int SearchDebounce { get; set; } = 300;
    [Parameter] public EventCallback<string> OnSearch { get; set; }
    
    // Filter parameters
    [Parameter] public bool ShowFilters { get; set; } = false;
    [Parameter] public RenderFragment? FiltersPanel { get; set; }
    [Parameter] public EventCallback OnToggleFilters { get; set; }
    
    // Export parameters
    [Parameter] public bool ShowExport { get; set; } = false;
    [Parameter] public List<string> ExportFormats { get; set; } = new() { "CSV", "Excel" };
    [Parameter] public EventCallback<string> OnExport { get; set; }
    [Parameter] public bool EnableExcelExport { get; set; } = true;
    [Parameter] public string ExcelFileName { get; set; } = "Export";
    private bool _isExporting = false;
    
    // Action parameters
    [Parameter] public List<EFTableAction>? Actions { get; set; }
    [Parameter] public bool UseDefaultActions { get; set; } = true;
    [Parameter] public EventCallback OnAdd { get; set; }
    [Parameter] public EventCallback<TItem> OnEdit { get; set; }
    [Parameter] public EventCallback<TItem> OnDelete { get; set; }
    [Parameter] public EventCallback<TItem> OnView { get; set; }
    [Parameter] public EventCallback<EFTableActionEventArgs> OnAction { get; set; }
    [Parameter] public EventCallback<TableRowClickEventArgs<TItem>> OnRowClick { get; set; }

    // Appearance parameters
    [Parameter] public bool Hover { get; set; } = true;
    [Parameter] public bool Striped { get; set; } = true;
    [Parameter] public bool Dense { get; set; } = true;
    [Parameter] public bool FixedHeader { get; set; } = false;
    [Parameter] public string? Height { get; set; }
    [Parameter] public string? MaxHeight { get; set; }
    [Parameter] public bool IsLoading { get; set; }
    [Parameter] public Color LoadingProgressColor { get; set; } = Color.Primary;
    [Parameter] public Breakpoint Breakpoint { get; set; } = Breakpoint.Sm;
    
    // Virtualization parameter for performance with large datasets
    [Parameter] public bool Virtualize { get; set; } = false;

    // Pager parameters
    [Parameter] public bool ShowInternalPager { get; set; } = false;
    [Parameter] public RenderFragment? PagerContent { get; set; }

    // Pagination control parameters
    [Parameter] public int RowsPerPage { get; set; } = int.MaxValue;
    [Parameter] public int[] PageSizeOptions { get; set; } = new[] { 10, 25, 50, 100 };
    [Parameter] public int TotalItems { get; set; } = 0;
    
    // Footer parameters
    [Parameter] public bool ShowFooter { get; set; } = true;

    // Column configuration
    [Parameter] public bool ShowColumnConfiguration { get; set; } = true;
    [Parameter] public string ComponentKey { get; set; } = "DefaultTable";
    [Parameter] public List<EFTableColumnConfiguration> InitialColumnConfigurations { get; set; } = new();

    // Content parameters
    [Parameter] public RenderFragment<List<EFTableColumnConfiguration>>? HeaderContent { get; set; }
    [Parameter] public RenderFragment<TItem>? RowTemplate { get; set; }
    [Parameter] public RenderFragment? ToolBarContent { get; set; }
    [Parameter] public RenderFragment? NoRecordsContent { get; set; }

    // Grouping
    [Parameter] public List<string> GroupByProperties { get; set; } = new();
    [Parameter] public bool AllowDragDropGrouping { get; set; } = true;

    // Table reference for external access
    [Parameter] public MudTable<TItem>? TableReference { get; set; }
    [Parameter] public EventCallback<MudTable<TItem>?> TableReferenceChanged { get; set; }

    // Public property to expose current column configurations
    public List<EFTableColumnConfiguration> ColumnConfigurations => _columnConfigurations;

    // Internal state
    private List<EFTableColumnConfiguration> _columnConfigurations = new();
    private EFTablePreferences? _preferences;
    private List<string> _groupByProperties = new();
    private Dictionary<int, object?> _lastGroupValues = new();
    private string? _draggedColumnProperty;
    private MudTable<TItem>? _lastTableRef;
    
    // Search state
    private string _searchTerm = string.Empty;
    private System.Threading.Timer? _searchTimer;
    private bool _filtersExpanded = false;

    protected override async Task OnInitializedAsync()
    {
        // Initialize column configurations
        _columnConfigurations = InitialColumnConfigurations.Select(c => new EFTableColumnConfiguration
        {
            PropertyName = c.PropertyName,
            DisplayName = c.DisplayName,
            IsVisible = c.IsVisible,
            Order = c.Order
        }).ToList();

        // Load preferences
        await LoadPreferencesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Update TableReference binding only when _tableRef actually changes
        if (_tableRef != null && TableReferenceChanged.HasDelegate && _tableRef != _lastTableRef)
        {
            _lastTableRef = _tableRef;
            await TableReferenceChanged.InvokeAsync(_tableRef);
        }
    }

    protected override void OnParametersSet()
    {
        // Only update grouping from parameter if:
        // 1. Preferences haven't been loaded yet (first initialization, _preferences is null)
        // 2. OR the parameter has a non-empty value that differs from current state
        // This ensures saved preferences take precedence over parameter defaults
        if (_preferences == null || (GroupByProperties.Any() && !_groupByProperties.SequenceEqual(GroupByProperties)))
        {
            _groupByProperties = new List<string>(GroupByProperties);
            _lastGroupValues.Clear();
        }
    }

    private async Task LoadPreferencesAsync()
    {
        try
        {
            _preferences = await TablePreferencesService.GetPreferencesAsync<EFTablePreferences>(ComponentKey);
            
            if (_preferences != null)
            {
                // Apply column order
                if (_preferences.ColumnOrders != null && _preferences.ColumnOrders.Any())
                {
                    foreach (var col in _columnConfigurations)
                    {
                        if (_preferences.ColumnOrders.TryGetValue(col.PropertyName, out var order))
                        {
                            col.Order = order;
                        }
                    }
                    _columnConfigurations = _columnConfigurations.OrderBy(c => c.Order).ToList();
                }

                // Apply visibility
                if (_preferences.ColumnVisibility != null && _preferences.ColumnVisibility.Any())
                {
                    foreach (var col in _columnConfigurations)
                    {
                        if (_preferences.ColumnVisibility.TryGetValue(col.PropertyName, out var isVisible))
                        {
                            col.IsVisible = isVisible;
                        }
                    }
                }

                // Apply grouping
                if (_preferences.GroupByProperties != null && _preferences.GroupByProperties.Any() && ServerData == null)
                {
                    _groupByProperties = new List<string>(_preferences.GroupByProperties);
                }

                Logger.LogDebug("Loaded table preferences for {ComponentKey}", ComponentKey);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading table preferences for {ComponentKey}", ComponentKey);
        }
    }

    private async Task SavePreferencesAsync()
    {
        try
        {
            var preferences = new EFTablePreferences
            {
                ColumnOrders = _columnConfigurations.ToDictionary(c => c.PropertyName, c => c.Order),
                ColumnVisibility = _columnConfigurations.ToDictionary(c => c.PropertyName, c => c.IsVisible),
                GroupByProperties = new List<string>(_groupByProperties)
            };

            await TablePreferencesService.SavePreferencesAsync(ComponentKey, preferences);
            Logger.LogDebug("Saved table preferences for {ComponentKey}", ComponentKey);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving table preferences for {ComponentKey}", ComponentKey);
        }
    }

    private async Task ResetPreferences()
    {
        try
        {
            await TablePreferencesService.ClearPreferencesAsync(ComponentKey);
            
            // Reset to initial state
            _columnConfigurations = InitialColumnConfigurations.Select(c => new EFTableColumnConfiguration
            {
                PropertyName = c.PropertyName,
                DisplayName = c.DisplayName,
                IsVisible = c.IsVisible,
                Order = c.Order
            }).ToList();
            
            _groupByProperties = new List<string>(GroupByProperties);
            _lastGroupValues.Clear();
            
            StateHasChanged();
            Logger.LogInformation("Reset table preferences for {ComponentKey}", ComponentKey);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error resetting table preferences for {ComponentKey}", ComponentKey);
        }
    }

    private async Task OpenColumnConfigurationDialog()
    {
        var parameters = new DialogParameters
        {
            { "Columns", _columnConfigurations },
            { "GroupByProperties", _groupByProperties },
            { "AvailableGroupProperties", _columnConfigurations.Select(c => c.PropertyName).ToList() },
            { "AllowGrouping", ServerData == null && Items != null } // Only allow grouping for client-side data
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<ColumnConfigurationDialog>(
            TranslationService.GetTranslation("table.columnConfiguration", "Configurazione colonne"),
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled && result.Data is EFTableColumnConfigurationResult configResult)
        {
            _columnConfigurations = configResult.Columns;
            _groupByProperties = new List<string>(configResult.GroupByProperties);
            _lastGroupValues.Clear();
            
            await SavePreferencesAsync();
            StateHasChanged();
        }
    }

    private IEnumerable<TItem> GetDisplayItems()
    {
        if (Items == null)
            return Enumerable.Empty<TItem>();

        var items = Items;

        // Apply multi-level grouping sort if needed
        if (_groupByProperties.Count > 0)
        {
            IOrderedEnumerable<TItem>? orderedItems = null;
            
            for (int i = 0; i < _groupByProperties.Count; i++)
            {
                var groupProperty = _groupByProperties[i];
                if (i == 0)
                {
                    orderedItems = items.OrderBy(item => GetPropertyValue(item, groupProperty));
                }
                else
                {
                    orderedItems = orderedItems!.ThenBy(item => GetPropertyValue(item, groupProperty));
                }
            }
            
            items = orderedItems ?? items;
        }

        return items;
    }

    private object? GetPropertyValue(TItem item, string propertyPath)
    {
        if (item == null || string.IsNullOrEmpty(propertyPath))
            return null;

        try
        {
            var property = typeof(TItem).GetProperty(propertyPath);
            return property?.GetValue(item);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error getting property value for {PropertyPath}", propertyPath);
            return null;
        }
    }

    public async Task ReloadServerDataAsync()
    {
        if (_tableRef != null && ServerData != null)
        {
            await _tableRef.ReloadServerData();
        }
    }

    // Drag & Drop methods
    public void HandleColumnDragStart(string propertyName)
    {
        _draggedColumnProperty = propertyName;
    }

    private void HandleGroupPanelDragOver(DragEventArgs e)
    {
        // Allow drop
        e.DataTransfer.DropEffect = "move";
    }

    private async Task HandleGroupPanelDrop(DragEventArgs e)
    {
        if (!string.IsNullOrEmpty(_draggedColumnProperty) && ServerData == null)
        {
            // Add to grouping if not already present
            if (!_groupByProperties.Contains(_draggedColumnProperty))
            {
                _groupByProperties.Add(_draggedColumnProperty);
                _lastGroupValues.Clear();
                
                await SavePreferencesAsync();
                StateHasChanged();
            }
            
            _draggedColumnProperty = null;
        }
    }

    private async Task RemoveGrouping(string? propertyName = null)
    {
        if (propertyName != null)
        {
            _groupByProperties.Remove(propertyName);
        }
        else
        {
            _groupByProperties.Clear();
        }
        
        _lastGroupValues.Clear();
        
        await SavePreferencesAsync();
        StateHasChanged();
    }

    private string GetColumnDisplayName(string propertyName)
    {
        var column = _columnConfigurations.FirstOrDefault(c => c.PropertyName == propertyName);
        return column?.DisplayName ?? propertyName;
    }

    private bool GroupItemsMatch(TItem item, int upToLevel)
    {
        for (int i = 0; i <= upToLevel; i++)
        {
            if (i >= _groupByProperties.Count)
                return false;
                
            var groupProperty = _groupByProperties[i];
            var itemValue = GetPropertyValue(item, groupProperty);
            
            if (!_lastGroupValues.ContainsKey(i))
                return false;
                
            if (!Equals(itemValue, _lastGroupValues[i]))
                return false;
        }
        return true;
    }

    private string GetGroupRowStyle(int level)
    {
        var paddingLeft = 12 + (level * 20);
        return $"padding: 12px 12px 12px {paddingLeft}px;";
    }

    private int GetTotalCount()
    {
        // For server-side data, use TotalItems if it has been explicitly set
        // We check against default value (0) and presence of ServerData to determine if TotalItems was intentionally set
        if (ServerData != null && TotalItems >= 0)
        {
            return TotalItems;
        }
        
        // For client-side data, count Items
        if (Items != null)
        {
            return Items.Count();
        }
        
        return 0;
    }

    // Search methods
    private async Task OnSearchTermChanged(string value)
    {
        _searchTerm = value;
        
        // Cancel previous timer if exists
        _searchTimer?.Dispose();
        
        // Create new timer for debounce
        if (SearchDebounce > 0)
        {
            _searchTimer = new System.Threading.Timer(async _ =>
            {
                await InvokeAsync(async () =>
                {
                    if (OnSearch.HasDelegate)
                    {
                        await OnSearch.InvokeAsync(_searchTerm);
                    }
                    StateHasChanged();
                });
            }, null, SearchDebounce, Timeout.Infinite);
        }
        else
        {
            if (OnSearch.HasDelegate)
            {
                await OnSearch.InvokeAsync(_searchTerm);
            }
        }
    }

    private async Task ToggleFilters()
    {
        _filtersExpanded = !_filtersExpanded;
        if (OnToggleFilters.HasDelegate)
        {
            await OnToggleFilters.InvokeAsync();
        }
        StateHasChanged();
    }

    private async Task HandleExport(string format)
    {
        if (OnExport.HasDelegate)
        {
            await OnExport.InvokeAsync(format);
        }
    }

    private async Task HandleExportToExcel()
    {
        if (!EnableExcelExport) return;
        try
        {
            _isExporting = true;
            StateHasChanged();
            
            var displayItems = GetDisplayItems().ToList();
            if (!displayItems.Any())
            {
                Snackbar.Add("No data to export", Severity.Warning);
                return;
            }
            
            var columns = _columnConfigurations.Where(c => c.IsVisible).OrderBy(c => c.Order)
                .Select(c => new { PropertyName = c.PropertyName, DisplayName = c.DisplayName, NumberFormat = GetExcelFormat(c.PropertyName), IsVisible = true }).ToList();
            
            var exportData = new
            {
                data = displayItems,
                options = new
                {
                    fileName = !string.IsNullOrEmpty(ExcelFileName) ? ExcelFileName : Title ?? "Export",
                    sheetName = Title ?? "Data",
                    columns,
                    formatting = new { headerBackgroundColor = "#1976D2", headerFontColor = "#FFFFFF", headerBold = true, headerBorders = true, alternateRowColors = true, alternateRowColor = "#F5F5F5", dataBorders = true },
                    autoFitColumns = true,
                    freezeHeader = true,
                    addAutoFilter = true
                }
            };
            
            var response = await Http.PostAsJsonAsync("/api/v1/export/excel", exportData);
            if (response.IsSuccessStatusCode)
            {
                var bytes = await response.Content.ReadAsByteArrayAsync();
                var fileName = response.Content.Headers.ContentDisposition?.FileName?.Trim('"') ?? $"Export_{DateTime.Now:yyyyMMdd_HHmmss}.xlsx";
                await JSRuntime.InvokeVoidAsync("downloadFileFromBytes", fileName, bytes);
                Snackbar.Add("Export completed!", Severity.Success);
            }
            else
            {
                Snackbar.Add("Export failed", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isExporting = false;
            StateHasChanged();
        }
    }

    private string? GetExcelFormat(string propertyName)
    {
        var property = typeof(TItem).GetProperty(propertyName);
        if (property == null) return null;
        var propType = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;
        if (propType == typeof(decimal) || propType == typeof(double) || propType == typeof(float))
        {
            if (propertyName.Contains("Price") || propertyName.Contains("Cost") || propertyName.Contains("Amount"))
                return "â‚¬#,##0.00";
            return "#,##0.00";
        }
        if (propType == typeof(DateTime)) return "dd/mm/yyyy hh:mm";
        if (propType == typeof(int) || propType == typeof(long)) return "#,##0";
        return null;
    }

    private async Task HandleAdd()
    {
        if (OnAdd.HasDelegate)
        {
            await OnAdd.InvokeAsync();
        }
    }

    private async Task HandleEdit(TItem item)
    {
        if (OnEdit.HasDelegate)
        {
            await OnEdit.InvokeAsync(item);
        }
    }

    private async Task HandleDelete(TItem item)
    {
        if (OnDelete.HasDelegate)
        {
            await OnDelete.InvokeAsync(item);
        }
    }

    private async Task HandleView(TItem item)
    {
        if (OnView.HasDelegate)
        {
            await OnView.InvokeAsync(item);
        }
    }

    private async Task HandleCustomAction(string actionId, object? payload = null)
    {
        if (OnAction.HasDelegate)
        {
            var args = new EFTableActionEventArgs
            {
                ActionId = actionId,
                Payload = payload
            };
            await OnAction.InvokeAsync(args);
        }
    }

    public void Dispose()
    {
        _searchTimer?.Dispose();
    }
}
