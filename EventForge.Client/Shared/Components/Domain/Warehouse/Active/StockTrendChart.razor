@using EventForge.DTOs.Warehouse
@using EventForge.Client.Services
@inject ITranslationService TranslationService

<CommonTrendWrapper Icon="@Icons.Material.Outlined.ShowChart" 
                   title="@TranslationService.GetTranslation("product.stockTrend","Andamento Giacenza")" 
                   Subtitle="@GetSubtitle()" 
                   ProductId="@ProductId">
    @if (IsLoading)
    {
        <div class="d-flex justify-center pa-4">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
        </div>
    }
    else if (StockTrend != null && StockTrend.DataPoints.Any())
    {
        <!-- Statistics Cards -->
        <MudStack Row="true" Spacing="2" Class="mb-4">
            <MudPaper Elevation="0" Class="pa-3 flex-grow-1" Style="border: 1px solid rgba(0,0,0,0.12); border-radius:4px; min-width: 150px;">
                <MudText Typo="Typo.caption" Class="mud-text-secondary">
                    @TranslationService.GetTranslation("stock.current", "Attuale")
                </MudText>
                <MudText Typo="Typo.h6" Color="Color.Primary">
                    @StockTrend.CurrentStock.ToString("N2")
                </MudText>
            </MudPaper>
            <MudPaper Elevation="0" Class="pa-3 flex-grow-1" Style="border: 1px solid rgba(0,0,0,0.12); border-radius:4px; min-width: 150px;">
                <MudText Typo="Typo.caption" Class="mud-text-secondary">
                    @TranslationService.GetTranslation("stock.average", "Media")
                </MudText>
                <MudText Typo="Typo.h6">
                    @StockTrend.AverageStock.ToString("N2")
                </MudText>
            </MudPaper>
            <MudPaper Elevation="0" Class="pa-3 flex-grow-1" Style="border: 1px solid rgba(0,0,0,0.12); border-radius:4px; min-width: 150px;">
                <MudText Typo="Typo.caption" Class="mud-text-secondary">
                    @TranslationService.GetTranslation("stock.minimum", "Minimo")
                </MudText>
                <MudText Typo="Typo.h6" Color="Color.Warning">
                    @StockTrend.MinStock.ToString("N2")
                </MudText>
            </MudPaper>
            <MudPaper Elevation="0" Class="pa-3 flex-grow-1" Style="border: 1px solid rgba(0,0,0,0.12); border-radius:4px; min-width: 150px;">
                <MudText Typo="Typo.caption" Class="mud-text-secondary">
                    @TranslationService.GetTranslation("stock.maximum", "Massimo")
                </MudText>
                <MudText Typo="Typo.h6" Color="Color.Success">
                    @StockTrend.MaxStock.ToString("N2")
                </MudText>
            </MudPaper>
        </MudStack>

        <!-- Chart -->
        <MudChart ChartType="ChartType.Line"
                  ChartSeries="@_series"
                  XAxisLabels="@_xAxisLabels"
                  Width="100%"
                  Height="350px"
                  ChartOptions="@_chartOptions">
        </MudChart>
    }
    else
    {
        <MudAlert Severity="Severity.Info">
            @TranslationService.GetTranslation("product.noStockTrendData", "Nessun dato di giacenza disponibile per questo periodo")
        </MudAlert>
    }
</CommonTrendWrapper>

@code {
    [Parameter, EditorRequired]
    public StockTrendDto? StockTrend { get; set; }

    [Parameter]
    public bool IsLoading { get; set; }

    [Parameter]
    public Guid? ProductId { get; set; }

    private List<ChartSeries> _series = new();
    private string[] _xAxisLabels = Array.Empty<string>();
    private ChartOptions _chartOptions = new();

    private string GetSubtitle()
    {
        if (StockTrend != null)
        {
            return $"{TranslationService.GetTranslation("stock.trendYear", "Anno")} {StockTrend.Year}";
        }
        return string.Empty;
    }

    protected override void OnParametersSet()
    {
        if (StockTrend?.DataPoints != null && StockTrend.DataPoints.Any())
        {
            PrepareChartData();
        }
    }

    private void PrepareChartData()
    {
        if (StockTrend == null || !StockTrend.DataPoints.Any())
            return;

        // Normalize all dates to UTC for consistent handling
        // Get daily stock increases grouped by date
        var dailyIncreases = StockTrend.StockIncreases
            .GroupBy(dp => DateTime.SpecifyKind(dp.Date, DateTimeKind.Utc).Date)
            .Select(g => new
            {
                Date = g.Key,
                Quantity = g.Sum(x => x.Quantity)
            })
            .ToDictionary(x => x.Date, x => x.Quantity);

        // Get daily stock decreases grouped by date
        var dailyDecreases = StockTrend.StockDecreases
            .GroupBy(dp => DateTime.SpecifyKind(dp.Date, DateTimeKind.Utc).Date)
            .Select(g => new
            {
                Date = g.Key,
                Quantity = g.Sum(x => x.Quantity)
            })
            .ToDictionary(x => x.Date, x => x.Quantity);

        // Get all unique dates from DataPoints, StockIncreases, and StockDecreases
        // This ensures future-dated movements are included in the chart
        var allDates = StockTrend.DataPoints
            .Select(dp => DateTime.SpecifyKind(dp.Date, DateTimeKind.Utc).Date)
            .Concat(StockTrend.StockIncreases.Select(dp => DateTime.SpecifyKind(dp.Date, DateTimeKind.Utc).Date))
            .Concat(StockTrend.StockDecreases.Select(dp => DateTime.SpecifyKind(dp.Date, DateTimeKind.Utc).Date))
            .Distinct()
            .OrderBy(d => d)
            .ToList();

        // Prepare X-axis labels (dates)
        _xAxisLabels = allDates
            .Select(d => d.ToString("dd/MM"))
            .ToArray();

        // Prepare series data with 0 fallback for missing values
        var increasesData = allDates.Select(date => dailyIncreases.TryGetValue(date, out var qty) ? (double)qty : 0).ToArray();
        var decreasesData = allDates.Select(date => dailyDecreases.TryGetValue(date, out var qty) ? (double)qty : 0).ToArray();
        
        // Get stock level data from DataPoints - handle duplicate dates by taking the last value
        var stockLevelDict = StockTrend.DataPoints
            .GroupBy(dp => DateTime.SpecifyKind(dp.Date, DateTimeKind.Utc).Date)
            .ToDictionary(g => g.Key, g => g.OrderBy(dp => dp.Date).Last().Quantity);
        var stockLevelData = allDates.Select(date => stockLevelDict.TryGetValue(date, out var qty) ? (double)qty : 0).ToArray();

        // Prepare series with three separate lines: Carichi, Scarichi, and Giacenza
        _series = new List<ChartSeries>
        {
            new ChartSeries
            {
                Name = TranslationService.GetTranslation("stock.stockLevel", "Giacenza"),
                Data = stockLevelData
            },
            new ChartSeries
            {
                Name = TranslationService.GetTranslation("stock.increases", "Carichi"),
                Data = increasesData
            },
            new ChartSeries
            {
                Name = TranslationService.GetTranslation("stock.decreases", "Scarichi"),
                Data = decreasesData
            }
        };

        // Configure chart options
        _chartOptions = new ChartOptions
        {
            YAxisTicks = 10,
            YAxisLines = true,
            XAxisLines = false,
            LineStrokeWidth = 3,
            InterpolationOption = InterpolationOption.Straight
        };
    }
}
