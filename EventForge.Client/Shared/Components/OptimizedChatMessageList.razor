@using EventForge.DTOs.Chat
@using Microsoft.AspNetCore.Components.Web.Virtualization
@inject IPerformanceOptimizationService PerformanceService
@inject ILogger<OptimizedChatMessageList> Logger
@using System.Collections.Concurrent
@implements IDisposable

<div class="chat-messages-container" style="height: @Height; overflow: auto;">
    @if (Messages?.Any() == true)
    {
        <Virtualize Items="@Messages" Context="message" ItemSize="@EstimatedItemSize" OverscanCount="@OverscanCount">
            <ItemContent>
                <div class="message-item @GetMessageCssClass(message)" @key="message.Id">
                    <!-- Optimized message rendering with minimal DOM -->
                    <div class="message-header">
                        <span class="message-sender">@message.SenderDisplayName</span>
                        <small class="message-time">@FormatMessageTime(message.Timestamp)</small>
                    </div>
                    <div class="message-content">
                        @if (!string.IsNullOrEmpty(message.Content))
                        {
                            <!-- Lazy load rich content rendering -->
                            @if (ShouldRenderRichContent(message))
                            {
                                @((MarkupString)ProcessRichContent(message.Content))
                            }
                            else
                            {
                                @message.Content
                            }
                        }
                        
                        @if (message.Attachments?.Any() == true)
                        {
                            <div class="message-attachments">
                                @foreach (var attachment in message.Attachments.Take(MaxAttachmentsToShow))
                                {
                                    <LazyAttachmentComponent Attachment="@attachment" />
                                }
                                @if (message.Attachments.Count > MaxAttachmentsToShow)
                                {
                                    <small>+@(message.Attachments.Count - MaxAttachmentsToShow) more</small>
                                }
                            </div>
                        }
                    </div>
                    
                    <!-- Message actions - only show for recent/hovered messages for performance -->
                    @if (ShouldShowMessageActions(message))
                    {
                        <div class="message-actions">
                            <MudButton Size="Size.Small" Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Reply"
                                       OnClick="@(() => OnReplyMessage?.Invoke(message))">
                                Reply
                            </MudButton>
                            @if (CanEditMessage(message))
                            {
                                <MudButton Size="Size.Small" Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Edit"
                                           OnClick="@(() => OnEditMessage?.Invoke(message))">
                                    Edit
                                </MudButton>
                            }
                        </div>
                    }
                </div>
            </ItemContent>
            <Placeholder>
                <!-- Optimized placeholder for unloaded items -->
                <div class="message-placeholder" style="height: @EstimatedItemSize">
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="60px" />
                </div>
            </Placeholder>
        </Virtualize>
    }
    else if (IsLoading)
    {
        <!-- Optimized loading state -->
        <div class="messages-loading">
            @for (int i = 0; i < 5; i++)
            {
                <div class="message-skeleton">
                    <MudSkeleton SkeletonType="SkeletonType.Text" Height="20px" Width="30%" />
                    <MudSkeleton SkeletonType="SkeletonType.Text" Height="40px" Width="80%" />
                </div>
            }
        </div>
    }
    else
    {
        <div class="no-messages">
            <MudText Typo="Typo.body1" Align="Align.Center" Class="text-muted">
                No messages yet. Start the conversation!
            </MudText>
        </div>
    }
</div>

@code {
    [Parameter] public List<ChatMessageDto>? Messages { get; set; }
    [Parameter] public string Height { get; set; } = "400px";
    [Parameter] public bool IsLoading { get; set; }
    [Parameter] public EventCallback<ChatMessageDto> OnReplyMessage { get; set; }
    [Parameter] public EventCallback<ChatMessageDto> OnEditMessage { get; set; }
    [Parameter] public Guid? CurrentUserId { get; set; }
    
    // Performance optimization parameters
    [Parameter] public int EstimatedItemSize { get; set; } = 80; // Estimated height of each message
    [Parameter] public int OverscanCount { get; set; } = 5; // Number of items to render outside viewport
    [Parameter] public int MaxAttachmentsToShow { get; set; } = 3; // Limit attachments for performance
    
    private readonly ConcurrentDictionary<Guid, string> _processedContentCache = new();
    private readonly HashSet<Guid> _visibleMessages = new();
    private Timer? _visibilityUpdateTimer;

    protected override void OnInitialized()
    {
        // Setup timer to update visible messages for performance optimizations
        _visibilityUpdateTimer = new Timer(UpdateVisibleMessages, null, 
            TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    private string GetMessageCssClass(ChatMessageDto message)
    {
        var cssClasses = new List<string> { "message" };
        
        if (message.SenderId == CurrentUserId)
            cssClasses.Add("message-own");
        else
            cssClasses.Add("message-other");
            
        if (IsRecentMessage(message))
            cssClasses.Add("message-recent");
            
        return string.Join(" ", cssClasses);
    }

    private bool IsRecentMessage(ChatMessageDto message)
    {
        return DateTime.UtcNow - message.Timestamp < TimeSpan.FromMinutes(5);
    }

    private string FormatMessageTime(DateTime timestamp)
    {
        var now = DateTime.UtcNow;
        var diff = now - timestamp;
        
        return diff.TotalMinutes < 1 ? "now" :
               diff.TotalHours < 1 ? $"{(int)diff.TotalMinutes}m ago" :
               diff.TotalDays < 1 ? $"{(int)diff.TotalHours}h ago" :
               timestamp.ToString("MMM dd");
    }

    private bool ShouldRenderRichContent(ChatMessageDto message)
    {
        // Only render rich content for recent messages or when explicitly requested
        return IsRecentMessage(message) && 
               (message.Content?.Contains("http") == true || 
                message.Content?.Contains("@") == true ||
                message.Content?.Contains("#") == true);
    }

    private string ProcessRichContent(string content)
    {
        // Cache processed content for performance
        if (_processedContentCache.TryGetValue(GetContentHash(content), out var cachedContent))
            return cachedContent;

        try
        {
            // Simple rich content processing - avoid heavy regex in production
            var processed = content
                .Replace("\n", "<br/>")
                .Replace("  ", "&nbsp;&nbsp;"); // Preserve spacing
            
            // Add basic URL detection (lightweight)
            if (content.Contains("http"))
            {
                processed = System.Text.RegularExpressions.Regex.Replace(
                    processed, 
                    @"(https?://[^\s]+)", 
                    "<a href=\"$1\" target=\"_blank\" rel=\"noopener\">$1</a>",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            }

            _processedContentCache[GetContentHash(content)] = processed;
            return processed;
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error processing rich content");
            return content; // Fallback to plain text
        }
    }

    private Guid GetContentHash(string content)
    {
        // Simple hash for caching - in production use proper hashing
        return new Guid(content.GetHashCode(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }

    private bool ShouldShowMessageActions(ChatMessageDto message)
    {
        // Only show actions for recent messages or own messages to reduce DOM complexity
        return IsRecentMessage(message) || message.SenderId == CurrentUserId;
    }

    private bool CanEditMessage(ChatMessageDto message)
    {
        return message.SenderId == CurrentUserId && 
               DateTime.UtcNow - message.Timestamp < TimeSpan.FromMinutes(15);
    }

    private void UpdateVisibleMessages(object? state)
    {
        // This would be used with Intersection Observer in JavaScript for better performance
        // For now, we'll keep it simple and update based on recent messages
        if (Messages?.Any() == true)
        {
            _visibleMessages.Clear();
            var recentMessages = Messages.Where(IsRecentMessage).Select(m => m.Id);
            foreach (var id in recentMessages)
            {
                _visibleMessages.Add(id);
            }
        }
    }

    protected override bool ShouldRender()
    {
        // Optimize rendering - only re-render when necessary
        return true; // Let Blazor handle this for now, but we could optimize further
    }

    public void Dispose()
    {
        _visibilityUpdateTimer?.Dispose();
        _processedContentCache.Clear();
    }
}

<style>
    .chat-messages-container {
        padding: 8px;
        scroll-behavior: smooth;
    }

    .message {
        margin-bottom: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        max-width: 70%;
        word-wrap: break-word;
        transition: background-color 0.2s ease;
    }

    .message-own {
        margin-left: auto;
        background-color: var(--mud-palette-primary-lighten);
        color: var(--mud-palette-primary-text);
    }

    .message-other {
        margin-right: auto;
        background-color: var(--mud-palette-background-grey);
    }

    .message-recent {
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .message-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
        font-size: 0.8rem;
    }

    .message-sender {
        font-weight: 600;
        color: var(--mud-palette-text-primary);
    }

    .message-time {
        color: var(--mud-palette-text-secondary);
        opacity: 0.7;
    }

    .message-content {
        line-height: 1.4;
    }

    .message-attachments {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
    }

    .message-actions {
        margin-top: 4px;
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .message:hover .message-actions {
        opacity: 1;
    }

    .message-placeholder {
        margin-bottom: 12px;
        padding: 8px 12px;
    }

    .messages-loading {
        padding: 16px;
    }

    .message-skeleton {
        margin-bottom: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .no-messages {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 200px;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
        .message {
            max-width: 85%;
            font-size: 0.9rem;
        }
        
        .message-header {
            font-size: 0.75rem;
        }
        
        .chat-messages-container {
            padding: 4px;
        }
    }
</style>